const t = (t, e=(t => void 0 !== t ? ": " + t : "")) => class extends Error {
    constructor(n) {
        super(t(n) + e(n))
    }
}
;
var e = {};
const n = t(( () => "Assertion failed"))
  , r = void 0 !== e && void 0 !== e.env || "undefined" != typeof __SNOWPACK_ENV__ && "production" === __SNOWPACK_ENV__.MODE && !__SNOWPACK_ENV__.UMBRELLA_ASSERTS && !__SNOWPACK_ENV__.SNOWPACK_PUBLIC_UMBRELLA_ASSERTS ? () => {}
: (t, e) => {
    if ("function" == typeof t && !t() || !t)
        throw new n("function" == typeof e ? e() : e)
}
;
class s {
    float(t=1) {
        return 2.3283064365386963e-10 * this.int() * t
    }
    norm(t=1) {
        return 2 * (2.3283064365386963e-10 * this.int() - .5) * t
    }
    minmax(t, e) {
        return this.float() * (e - t) + t
    }
}
const a = Math.random;
const i = new class extends s {
    int() {
        return 4294967296 * a() >>> 0
    }
    float(t=1) {
        return a() * t
    }
    norm(t=1) {
        return 2 * (a() - .5) * t
    }
}
  , o = (t, e=t.length, n=i) => ( (t, e=0, n=t.length, s=i) => {
    r(e >= 0 && n >= e && n <= t.length, `illegal range ${e}..${n}`);
    let a = n - e;
    const o = a;
    if (o > 1)
        for (; a-- > 0; ) {
            const n = e + s.float(o) | 0
              , r = e + s.float(o) | 0
              , a = t[n];
            t[n] = t[r],
            t[r] = a
        }
    return t
}
)(t, 0, e, n)
  , l = (t, e) => t === e ? 0 : null == t ? null == e ? 0 : -1 : null == e ? null == t ? 0 : 1 : "function" == typeof t.compare ? t.compare(e) : "function" == typeof e.compare ? -e.compare(t) : t < e ? -1 : t > e ? 1 : 0
  , h = (t, e, n) => {
    const r = t[e];
    t[e] = t[n],
    t[n] = r
}
;
function c(t, e=l, n=h, r=0, s=t.length - 1) {
    if (r < s) {
        const a = t[r + (s - r >> 1)];
        let i = r - 1
          , o = s + 1;
        for (; ; ) {
            do {
                i++
            } while (e(t[i], a) < 0);
            do {
                o--
            } while (e(t[o], a) > 0);
            if (i >= o)
                break;
            n(t, i, o)
        }
        c(t, e, n, r, o),
        c(t, e, n, o + 1, s)
    }
    return t
}
const f = (t, e, n=l) => {
    const s = "function" == typeof e ? t.map(e) : e;
    return r(s.length === t.length, "keys.length != src.length"),
    c(s, n, ( (...t) => {
        const [e,n,r] = t
          , s = t.length;
        switch (s) {
        case 0:
            return h;
        case 1:
            return (t, n, r) => {
                h(t, n, r),
                h(e, n, r)
            }
            ;
        case 2:
            return (t, r, s) => {
                h(t, r, s),
                h(e, r, s),
                h(n, r, s)
            }
            ;
        case 3:
            return (t, s, a) => {
                h(t, s, a),
                h(e, s, a),
                h(n, s, a),
                h(r, s, a)
            }
            ;
        default:
            return (e, n, r) => {
                h(e, n, r);
                for (let e = s; e-- > 0; )
                    h(t[e], n, r)
            }
        }
    }
    )(t)),
    t
}
  , u = t(( () => "unsupported operation"))
  , d = t => {
    throw new u(t)
}
;
var g, b;
(b = g || (g = {}))[b.FINE = 0] = "FINE",
b[b.DEBUG = 1] = "DEBUG",
b[b.INFO = 2] = "INFO",
b[b.WARN = 3] = "WARN",
b[b.SEVERE = 4] = "SEVERE",
b[b.NONE = 5] = "NONE";
let m = Object.freeze({
    level: g.NONE,
    fine() {},
    debug() {},
    info() {},
    warn() {},
    severe() {}
});
const p = Symbol();
function y(t, e, n) {
    const r = {}
      , s = e ? $(e) : {}
      , a = (...e) => {
        const n = t(...e)
          , a = r[n] || w(r, s, n) || r[p];
        return a ? a(...e) : d(`missing implementation for: "${n.toString()}"`)
    }
    ;
    return a.add = (t, e) => (r[t] && m.warn(`overwriting '${t.toString()}' impl`),
    r[t] = e,
    !0),
    a.addAll = t => {
        let e = !0;
        for (let n in t)
            e = a.add(n, t[n]) && e;
        return p in t && a.setDefault(t[p]),
        e
    }
    ,
    a.setDefault = t => a.add(p, t),
    a.remove = t => !!r[t] && (delete r[t],
    !0),
    a.callable = (...e) => {
        const n = t(...e);
        return !!(r[n] || w(r, s, n) || r[p])
    }
    ,
    a.isa = (t, e) => {
        let n = s[t];
        !n && (s[t] = n = new Set),
        n.add(e)
    }
    ,
    a.impls = () => {
        const t = new Set(Object.keys(r));
        for (let e in s)
            w(r, s, e) && t.add(e);
        return r[p] && t.add(p),
        t
    }
    ,
    a.rels = () => s,
    a.parents = t => s[t],
    a.ancestors = t => new Set(A([], s, t)),
    a.dependencies = function*() {
        for (let t in s)
            for (let e of s[t])
                yield[t, e];
        for (let t in r)
            !s[t] && (yield[t, void 0])
    }
    ,
    n && a.addAll(n),
    a
}
const w = (t, e, n) => {
    const r = e[n];
    if (r)
        for (let n of r) {
            let r = t[n] || w(t, e, n);
            if (r)
                return r
        }
}
  , A = (t, e, n) => {
    const r = e[n];
    if (r)
        for (let n of r)
            t.push(n),
            A(t, e, n);
    return t
}
  , $ = t => {
    const e = {};
    for (let n in t) {
        const r = t[n];
        e[n] = r instanceof Set ? r : Array.isArray(r) ? new Set(r) : new Set([r])
    }
    return e
}
  , x = (t, e, n) => t < e ? e : t > n ? n : t
  , v = t => t < 0 ? 0 : t > 1 ? 1 : t
  , U = Math.PI
  , R = 2 * U
  , E = 1 / R;
Math.sqrt(5),
Math.SQRT2,
Math.sqrt(3);
const z = (t, e) => t - e * Math.floor(t / e)
  , M = t => t - Math.floor(t)
  , k = (t, e, n, r) => (!t && (t = []),
t[0] = e,
t[1] = n,
t[2] = r,
t)
  , S = (t, e, n, r, s) => (!t && (t = []),
t[0] = e,
t[1] = n,
t[2] = r,
t[3] = s,
t)
  , O = (t, e=1) => null != t ? v(t) : e
  , N = (t, e, n) => 0 !== e ? t + n.norm(e) : t
  , G = (t, e, n, r=v) => 0 !== e ? r(t + n.norm(e)) : t
  , I = (t, e, n) => G(t, e, n, M)
  , B = (t, e, n) => (r, s, a, o=i) => S(r || s, t(s[0], a, o), e(s[1], a, o), n(s[2], a, o), O(s[3]))
  , _ = B(I, G, G)
  , j = B(G, G, G)
  , F = B(G, N, N)
  , D = y(( (t, e) => e.mode), {}, {
    hcy: _,
    hsi: _,
    hsl: _,
    hsv: _,
    lab50: F,
    lab65: F,
    lch: B(G, G, I),
    ycc: F,
    [p]: j
})
  , C = Array.isArray
  , L = t => "number" == typeof t
  , P = t => "string" == typeof t
  , q = t(( () => "illegal argument(s)"))
  , W = t => {
    throw new q(t)
}
  , T = (t=i) => t.float() < .5
  , V = (t, e, n=i) => {
    const s = t.length;
    r(s > 0, "no choices given");
    const a = e ? t.map(( (t, n) => [e[n] || 0, t])).sort(( (t, e) => e[0] - t[0])) : t.map((t => [1, t]))
      , o = a.reduce(( (t, e) => t + e[0]), 0);
    return o <= 0 && console.warn("total weights <= 0"),
    () => {
        const t = n.float(o);
        let e = o;
        for (let n = 0; n < s; n++)
            if (e -= a[n][0],
            e <= t)
                return a[n][1]
    }
}
;
var H, K;
(K = H || (H = {}))[K.RED = 0] = "RED",
K[K.ORANGE = 1] = "ORANGE",
K[K.YELLOW = 2] = "YELLOW",
K[K.CHARTREUSE = 3] = "CHARTREUSE",
K[K.GREEN = 4] = "GREEN",
K[K.SPRING_GREEN = 5] = "SPRING_GREEN",
K[K.CYAN = 6] = "CYAN",
K[K.AZURE = 7] = "AZURE",
K[K.BLUE = 8] = "BLUE",
K[K.VIOLET = 9] = "VIOLET",
K[K.MAGENTA = 10] = "MAGENTA",
K[K.ROSE = 11] = "ROSE";
class Y {
    constructor(t, e) {
        this.mode = t,
        this.value = e
    }
    deref() {
        return this.value
    }
}
const J = {
    aliceblue: "f0f8ff",
    antiquewhite: "faebd7",
    aqua: "0ff",
    aquamarine: "7fffd4",
    azure: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "000",
    blanchedalmond: "ffebcd",
    blue: "00f",
    blueviolet: "8a2be2",
    brown: "a52a2a",
    burlywood: "deb887",
    cadetblue: "5f9ea0",
    chartreuse: "7fff00",
    chocolate: "d2691e",
    coral: "ff7f50",
    cornflowerblue: "6495ed",
    cornsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "0ff",
    darkblue: "00008b",
    darkcyan: "008b8b",
    darkgoldenrod: "b8860b",
    darkgray: "a9a9a9",
    darkgreen: "006400",
    darkgrey: "a9a9a9",
    darkkhaki: "bdb76b",
    darkmagenta: "8b008b",
    darkolivegreen: "556b2f",
    darkorange: "ff8c00",
    darkorchid: "9932cc",
    darkred: "8b0000",
    darksalmon: "e9967a",
    darkseagreen: "8fbc8f",
    darkslateblue: "483d8b",
    darkslategray: "2f4f4f",
    darkslategrey: "2f4f4f",
    darkturquoise: "00ced1",
    darkviolet: "9400d3",
    deeppink: "ff1493",
    deepskyblue: "00bfff",
    dimgray: "696969",
    dimgrey: "696969",
    dodgerblue: "1e90ff",
    firebrick: "b22222",
    floralwhite: "fffaf0",
    forestgreen: "228b22",
    fuchsia: "f0f",
    gainsboro: "dcdcdc",
    ghostwhite: "f8f8ff",
    gold: "ffd700",
    goldenrod: "daa520",
    gray: "808080",
    grey: "808080",
    green: "008000",
    greenyellow: "adff2f",
    honeydew: "f0fff0",
    hotpink: "ff69b4",
    indianred: "cd5c5c",
    indigo: "4b0082",
    ivory: "fffff0",
    khaki: "f0e68c",
    lavender: "e6e6fa",
    lavenderblush: "fff0f5",
    lawngreen: "7cfc00",
    lemonchiffon: "fffacd",
    lightblue: "add8e6",
    lightcoral: "f08080",
    lightcyan: "e0ffff",
    lightgoldenrodyellow: "fafad2",
    lightgray: "d3d3d3",
    lightgreen: "90ee90",
    lightgrey: "d3d3d3",
    lightpink: "ffb6c1",
    lightsalmon: "ffa07a",
    lightseagreen: "20b2aa",
    lightskyblue: "87cefa",
    lightslategray: "789",
    lightslategrey: "789",
    lightsteelblue: "b0c4de",
    lightyellow: "ffffe0",
    lime: "0f0",
    limegreen: "32cd32",
    linen: "faf0e6",
    magenta: "f0f",
    maroon: "800000",
    mediumaquamarine: "66cdaa",
    mediumblue: "0000cd",
    mediumorchid: "ba55d3",
    mediumpurple: "9370db",
    mediumseagreen: "3cb371",
    mediumslateblue: "7b68ee",
    mediumspringgreen: "00fa9a",
    mediumturquoise: "48d1cc",
    mediumvioletred: "c71585",
    midnightblue: "191970",
    mintcream: "f5fffa",
    mistyrose: "ffe4e1",
    moccasin: "ffe4b5",
    navajowhite: "ffdead",
    navy: "000080",
    oldlace: "fdf5e6",
    olive: "808000",
    olivedrab: "6b8e23",
    orange: "ffa500",
    orangered: "ff4500",
    orchid: "da70d6",
    palegoldenrod: "eee8aa",
    palegreen: "98fb98",
    paleturquoise: "afeeee",
    palevioletred: "db7093",
    papayawhip: "ffefd5",
    peachpuff: "ffdab9",
    peru: "cd853f",
    pink: "ffc0cb",
    plum: "dda0dd",
    powderblue: "b0e0e6",
    purple: "800080",
    red: "f00",
    rosybrown: "bc8f8f",
    royalblue: "4169e1",
    saddlebrown: "8b4513",
    salmon: "fa8072",
    sandybrown: "f4a460",
    seagreen: "2e8b57",
    seashell: "fff5ee",
    sienna: "a0522d",
    silver: "c0c0c0",
    skyblue: "87ceeb",
    slateblue: "6a5acd",
    slategray: "708090",
    slategrey: "708090",
    snow: "fffafa",
    springgreen: "00ff7f",
    steelblue: "4682b4",
    tan: "d2b48c",
    teal: "008080",
    thistle: "d8bfd8",
    tomato: "ff6347",
    turquoise: "40e0d0",
    violet: "ee82ee",
    wheat: "f5deb3",
    white: "fff",
    whitesmoke: "f5f5f5",
    yellow: "ff0",
    yellowgreen: "9acd32",
    transparent: "0000",
    rebeccapurple: "639"
};
let Z = {
    canvas: "fff",
    canvastext: "000",
    linktext: "001ee4",
    visitedtext: "4e2386",
    activetext: "eb3323",
    buttonface: "ddd",
    buttontext: "000",
    buttonborder: "000",
    field: "fff",
    fieldtext: "000",
    highlight: "bbd5fb",
    highlighttext: "000",
    mark: "000",
    marktext: "fff",
    graytext: "808080"
};
function Q(t, e) {
    return !e && (e = {}),
    (...n) => {
        const r = JSON.stringify(n);
        return void 0 !== r ? r in e ? e[r] : e[r] = t.apply(null, n) : t.apply(null, n)
    }
}
const X = Q(( (t, e) => t.repeat(e)))
  , tt = Q(( (t, e=" ") => {
    const n = X(String(e), t);
    return (e, r) => null == e ? n : (e = e.toString(),
    (r = void 0 !== r ? r : e.length) < t ? n.substr(r) + e : e)
}
))
  , et = (tt(2, "0"),
tt(3, "0"),
tt(4, "0"),
Q(( (t, e=!1) => e ? e => rt(e) || e.toFixed(t) : e => e.toFixed(t))))
  , nt = (Q(( (t, e=3) => {
    const n = t - e - 1
      , r = Math.pow(10, n)
      , s = -Math.pow(10, n - 1)
      , a = Math.pow(10, -(e - 1))
      , i = tt(t);
    return n => {
        const o = Math.abs(n);
        return i(rt(n) || (0 === n ? "0" : o < a || o >= r ? nt(n, t) : n.toFixed(e - (n < s ? 1 : 0))))
    }
}
)),
(t, e) => t.toExponential(Math.max(e - 4 - (Math.log(Math.abs(t)) / Math.LN10 >= 10 ? 2 : 1) - (t < 0 ? 1 : 0), 0)))
  , rt = t => isNaN(t) ? "NaN" : t === 1 / 0 ? "+∞" : t === -1 / 0 ? "-∞" : void 0
  , st = (t=0) => e => (100 * e).toFixed(t) + "%"
  , at = (Object.freeze([0, 0, 0, 1]),
Object.freeze([1, 1, 1, 1]),
Object.freeze([1, 0, 0, 1]),
Object.freeze([0, 1, 0, 1]),
Object.freeze([0, 0, 1, 1]),
Object.freeze([0, 1, 1, 1]),
Object.freeze([1, 0, 1, 1]),
Object.freeze([1, 1, 0, 1]),
[.2126, .7152, .0722])
  , it = [.4360747, .2225045, .0139322, .3850649, .7168786, .0971045, .1430804, .0606169, .7141733]
  , ot = [3.1338561, -.9787684, .0719453, -1.6168667, 1.9161415, -.2289914, -.4906146, .033454, 1.4052427]
  , lt = [3.2404542, -.969266, .0556434, -1.5371385, 1.8760108, -.2040259, -.4985314, .041556, 1.0572252]
  , ht = [1.0478112, .0295424, -.0092345, .0228866, .9904844, .0150436, -.050127, -.0170491, .7521316]
  , ct = [.96422, 1, .82521]
  , ft = [.95047, 1, 1.08883];
et(3),
st(3);
const ut = (t, e) => S(t || [], .00392156862745098 * (e >>> 16 & 255), .00392156862745098 * (e >>> 8 & 255), .00392156862745098 * (255 & e), .00392156862745098 * (e >>> 24))
  , dt = (t, e) => S(t || [], .00392156862745098 * (255 & e), .00392156862745098 * (e >>> 8 & 255), .00392156862745098 * (e >>> 16 & 255), .00392156862745098 * (e >>> 24))
  , gt = t => {
    t = (P(t) ? t : t.deref()).toLowerCase();
    const e = J[t] || Z[t];
    if (e || "#" === t[0])
        return new Y("srgb",ut([], $t(e || t)));
    const n = t.split(/[(),/ ]+/)
      , [s,a,i,o,l] = n;
    switch (r(5 === n.length || 6 === n.length, `invalid ${s} color: ${t}`),
    s) {
    case "rgb":
    case "rgba":
        return new Y("srgb",[At(a), At(i), At(o), pt(l)]);
    case "hsl":
    case "hsla":
        return new Y("hsl",[mt(a), yt(i), yt(o), pt(l)]);
    case "lab":
        return new Y("lab50",[yt(a, !1), .01 * wt(i), .01 * wt(o), pt(l)]);
    case "lch":
        return new Y("lch",[yt(a, !1), .01 * wt(i), mt(o), pt(l)]);
    default:
        d(`color mode: ${s}`)
    }
}
  , bt = {
    rad: R,
    grad: 400,
    turn: 1,
    deg: 360,
    undefined: 360
}
  , mt = t => {
    const e = /^(-?[0-9.]+)(deg|rad|grad|turn)?$/.exec(t);
    return r(!!e, `expected hue, got: ${t}`),
    M(parseFloat(e[1]) / bt[e[2]])
}
  , pt = t => t ? At(t, 1) : 1
  , yt = (t, e=!0) => {
    r(/^([0-9.]+)%$/.test(t), `expected percentage, got: ${t}`);
    const n = parseFloat(t) / 100;
    return e ? v(n) : n
}
  , wt = t => (r(/^-?[0-9.]+$/.test(t), `expected number, got: ${t}`),
parseFloat(t))
  , At = (t, e=255, n=!0) => {
    r(/^-?[0-9.]+%?$/.test(t), `expected number or percentage, got: ${t}`);
    const s = parseFloat(t) / (t.endsWith("%") ? 100 : e);
    return n ? v(s) : s
}
  , $t = t => {
    const e = /^#?([0-9a-f]{3,8})$/i.exec(t);
    if (e) {
        const t = e[1];
        switch (t.length) {
        case 3:
            return (4278190080 | (4352 * (3840 & (n = parseInt(t, 16))) | 272 * (240 & n) | 17 * (15 & n))) >>> 0;
        case 4:
            return (t => (69632 * (61440 & t) | 4352 * (3840 & t) | 272 * (240 & t) | 17 * (15 & t)) >>> 0)(parseInt(t, 16)) >>> 0;
        case 6:
            return (4278190080 | parseInt(t, 16)) >>> 0;
        case 8:
            return parseInt(t, 16) >>> 0
        }
    }
    var n;
    return W(`invalid hex color: "${t}"`)
}
  , xt = (t, e) => null != t && "function" == typeof t[e]
  , vt = t => null != t && "function" != typeof t && void 0 !== t.length
  , Ut = Q(( (t, e=3, n=",", r="[", s="]") => {
    const a = "number" == typeof e ? et(e) : e;
    switch (t) {
    case 1:
        return t => `${r}${a(t[0])}${s}`;
    case 2:
        return t => `${r}${a(t[0])}${n}${a(t[1])}${s}`;
    case 3:
        return t => `${r}${a(t[0])}${n}${a(t[1])}${n}${a(t[2])}${s}`;
    case 4:
        return t => `${r}${a(t[0])}${n}${a(t[1])}${n}${a(t[2])}${n}${a(t[3])}${s}`;
    default:
        return t => {
            const e = [];
            for (let n = 0; n < t.length; n++)
                e.push(a(t[n]));
            return `${r}${e.join(n)}${s}`
        }
    }
}
));
var Rt, Et;
(Et = Rt || (Rt = {}))[Et.I8 = 5120] = "I8",
Et[Et.U8 = 5121] = "U8",
Et[Et.I16 = 5122] = "I16",
Et[Et.U16 = 5123] = "U16",
Et[Et.I32 = 5124] = "I32",
Et[Et.U32 = 5125] = "U32",
Et[Et.F32 = 5126] = "F32";
const zt = {
    [Rt.I8]: "i8",
    [Rt.U8]: "u8",
    [Rt.I16]: "i16",
    [Rt.U16]: "u16",
    [Rt.I32]: "i32",
    [Rt.U32]: "u32",
    [Rt.F32]: "f32"
}
  , Mt = (Rt.I8,
Rt.U8,
Rt.U8,
Rt.I16,
Rt.U16,
Rt.I32,
Rt.U32,
Rt.F32,
{
    ...{
        f32: Float32Array,
        f64: Float64Array
    },
    ...{
        i8: Int8Array,
        i16: Int16Array,
        i32: Int32Array
    },
    ...{
        u8: Uint8Array,
        u8c: Uint8ClampedArray,
        u16: Uint16Array,
        u32: Uint32Array
    }
})
  , kt = t => {
    const e = zt[t];
    return void 0 !== e ? e : t
}
;
function St(t, ...e) {
    return new (Mt[kt(t)])(...e)
}
const Ot = (t, e, n, r, s, a) => {
    const i = [];
    for (; n-- > 0; )
        i.push(new t(e,r,s)),
        r += a;
    return i
}
  , Nt = t(( () => "illegal arity"))
  , Gt = t => {
    throw new Nt(t)
}
;
function It(...t) {
    let[e,n,r,s,a,i,o,l,h,c] = t;
    switch (t.length) {
    case 0:
        Gt(0);
    case 1:
        return e;
    case 2:
        return (...t) => e(n(...t));
    case 3:
        return (...t) => e(n(r(...t)));
    case 4:
        return (...t) => e(n(r(s(...t))));
    case 5:
        return (...t) => e(n(r(s(a(...t)))));
    case 6:
        return (...t) => e(n(r(s(a(i(...t))))));
    case 7:
        return (...t) => e(n(r(s(a(i(o(...t)))))));
    case 8:
        return (...t) => e(n(r(s(a(i(o(l(...t))))))));
    case 9:
        return (...t) => e(n(r(s(a(i(o(l(h(...t)))))))));
    default:
        const f = (...t) => e(n(r(s(a(i(o(l(h(c(...t))))))))));
        return 10 === t.length ? f : It(f, ...t.slice(10))
    }
}
const Bt = t => xt(t, "xform") ? t.xform() : t;
function _t(...t) {
    return t = t.map(Bt),
    It.apply(null, t)
}
const jt = t => null != t && "function" == typeof t[Symbol.iterator]
  , Ft = (t, e) => [t[0], t[1], e]
  , Dt = Symbol()
  , Ct = () => {}
;
class Lt {
    constructor(t) {
        this.value = t
    }
    deref() {
        return this.value
    }
}
const Pt = t => t instanceof Lt
  , qt = t => t instanceof Lt ? t : new Lt(t)
  , Wt = t => t instanceof Lt ? t.deref() : t
  , Tt = t => 2 === t.length ? [void 0, t[1]] : 3 === t.length ? [t[1], t[2]] : Gt(t.length);
function Vt(...t) {
    const e = t[0]
      , n = e[0]
      , r = e[1]
      , s = e[2]
      , a = null == (t = Tt(t))[0] ? n() : t[0]
      , i = t[1];
    return Wt(r(xt(i, "$reduce") ? i.$reduce(s, a) : vt(i) ? Ht(s, a, i) : Kt(s, a, i)))
}
const Ht = (t, e, n) => {
    for (let r = 0, s = n.length; r < s; r++)
        if (e = t(e, n[r]),
        Pt(e)) {
            e = e.deref();
            break
        }
    return e
}
  , Kt = (t, e, n) => {
    for (let r of n)
        if (e = t(e, r),
        Pt(e)) {
            e = e.deref();
            break
        }
    return e
}
  , Yt = (t, e) => [t, t => t, e];
function *Jt(t, e) {
    const n = Bt(t)(function(t) {
        return t ? [...t] : Yt(( () => []), ( (t, e) => (t.push(e),
        t)))
    }())
      , r = n[1]
      , s = n[2];
    for (let t of e) {
        const e = s([], t);
        if (Pt(e))
            return void (yield*Wt(r(e.deref())));
        e.length && (yield*e)
    }
    yield*Wt(r([]))
}
function *Zt(t, e) {
    const n = Bt(t)([Ct, Ct, (t, e) => e])[2];
    for (let t of e) {
        let e = n(Dt, t);
        if (Pt(e))
            return e = Wt(e.deref()),
            void (e !== Dt && (yield e));
        e !== Dt && (yield e)
    }
}
function Qt(t, e) {
    return jt(e) ? Zt(Qt(t), e) : e => {
        const n = e[2];
        return Ft(e, ( (e, r) => n(e, t(r))))
    }
}
function Xt(...t) {
    return ( (t, e, n=Zt) => {
        const r = e.length - 1;
        return jt(e[r]) ? e.length > 1 ? n(t.apply(null, e.slice(0, r)), e[r]) : n(t(), e[0]) : void 0
    }
    )(Xt, t) || (e => {
        const n = e[2]
          , r = t[0];
        let s = t[1] || 0;
        return Ft(e, ( (t, e) => n(t, r(s++, e))))
    }
    )
}
function te(t, e, n) {
    return new ee(t,e,n)
}
class ee {
    constructor(t, e, n) {
        void 0 === t ? (t = 0,
        e = 1 / 0) : void 0 === e && (e = t,
        t = 0),
        n = void 0 === n ? t < e ? 1 : -1 : n,
        this.from = t,
        this.to = e,
        this.step = n
    }
    *[Symbol.iterator]() {
        let {from: t, to: e, step: n} = this;
        if (n > 0)
            for (; t < e; )
                yield t,
                t += n;
        else if (n < 0)
            for (; t > e; )
                yield t,
                t += n
    }
    $reduce(t, e) {
        const n = this.step;
        if (n > 0)
            for (let r = this.from, s = this.to; r < s && !Pt(e); r += n)
                e = t(e, r);
        else
            for (let r = this.from, s = this.to; r > s && !Pt(e); r += n)
                e = t(e, r);
        return e
    }
}
function ne(t, e) {
    t = t || "";
    let n = !0;
    return e ? [...e].join(t) : Yt(( () => ""), ( (e, r) => (e = n ? e + r : e + t + r,
    n = !1,
    e)))
}
function re(t, e) {
    return jt(e) ? Jt(re(t), e) : e => {
        const n = e[2];
        let r = t;
        return Ft(e, ( (t, e) => --r > 0 ? n(t, e) : 0 === r ? qt(n(t, e)) : (t => new Lt(t))(t)))
    }
}
function se(...t) {
    return ae(se, Vt, t)
}
const ae = (t, e, n) => {
    let r, s;
    switch (n.length) {
    case 4:
        s = n[3],
        r = n[2];
        break;
    case 3:
        s = n[2];
        break;
    case 2:
        return Qt((e => t(n[0], n[1], e)));
    default:
        Gt(n.length)
    }
    return e(Bt(n[0])(n[1]), r, s)
}
;
function *ie(...t) {
    const e = t.map((t => t[Symbol.iterator]()));
    for (; ; ) {
        const t = [];
        for (let n of e) {
            let e = n.next();
            if (e.done)
                return;
            t.push(e.value)
        }
        yield t
    }
}
const oe = (t=0) => {
    const e = new Array(5);
    let n;
    const r = (...r) => {
        const s = e[r[t].length] || n;
        return s ? s(...r) : d(`no impl for vec size ${r[t].length}`)
    }
    ;
    return r.add = (t, n) => e[t] = n,
    r.default = t => n = t,
    r.impl = t => e[t] || n,
    r
}
  , le = (t="op") => ([e,n]) => `${e}=${t}(${n});`
  , he = (t="op") => ([e,n,r,s]) => `${e}=${t}(${n},${r},${s});`
  , ce = ([t,e]) => `${t}*${e}`
  , fe = t => Qt((t => e => e > 1 ? `${t}[i${t}+${e}*s${t}]` : 1 == e ? `${t}[i${t}+s${t}]` : `${t}[i${t}]`)(t), te())
  , ue = t => Qt((e => `${t}[${e}]`), te())
  , de = (t, e, n, r="a", s="", a="", i="", o=!1) => [a, se(_t(re(t), Xt(( (t, n) => e(n, t)))), ne(s), ie.apply(null, n.split(",").map(o ? fe : ue))), i, "" !== r ? `return ${r};` : ""]
  , ge = (t, e, n="a", r, s, a=!1) => [r, "for(let i=a.length;--i>=0;) {", t(e.split(",").map(a ? t => `${t}[i${t}+i*s${t}]` : t => `${t}[i]`)), "}", s, null !== n ? `return ${n};` : ""]
  , be = (t, e) => `!${t} && (${t}=${e.split(",")[1]});`
  , me = (t, e, n, r=n, s="a", a, i, o, l=!1) => new Function(n,de(t, e, r, s, a, i, o, l).join(""))
  , pe = (t, e, n, r, s, a=s, i="a", o="", l, h, c=!1) => new Function(r,`return (${s})=>{${de(t, n, a, i, o, l, h, c).join("")}}`)(...e)
  , ye = (t, e, n=e, r="a", s, a, i=!1) => new Function(e,ge(t, n, r, s, a, i).join(""))
  , we = (t, e="o,a,b", n, r="o", s=1, a) => {
    n = n || e,
    a = null != a ? a : be(r, e);
    const i = oe(s)
      , o = s => i.add(s, me(s, t, e, n, r, "", a));
    return i.default(ye(t, e, n, r, a)),
    [i, o(2), o(3), o(4)]
}
  , Ae = (t, e, n="o,a", r, s="o", a=1, i) => {
    const o = e || le("op");
    r = r || n,
    i = null != i ? i : be(s, n);
    const l = oe(a)
      , h = e => l.add(e, pe(e, [t], o, "op", n, r, s, "", i));
    return l.default(( (t, e, n, r, s=r, a="a", i, o, l=!1) => new Function(n,`return (${r})=>{${ge(e, s, a, i, o, l).join("")}}`)(...t))([t], o, "op", n, r, s, i)),
    [l, h(2), h(3), h(4)]
}
  , [$e,xe,ve,Ue] = Ae(x, he(), "o,a,b,c")
  , [Re,Ee,ze,Me] = Ae(v, he(), "o,a,b,c")
  , [ke,Se,Oe,Ne] = Ae((t => t < -1 ? -1 : t > 1 ? 1 : t), he(), "o,a,b,c")
  , Ge = (t, e, n, r=!0, s=!0) => {
    const a = n > 0 ? r ? function() {
        return this.buf[this.offset + n * this.stride]
    }
    : function() {
        return this.buf[this.offset + n]
    }
    : function() {
        return this.buf[this.offset]
    }
      , i = n > 0 ? r ? function(t) {
        this.buf[this.offset + n * this.stride] = t
    }
    : function(t) {
        this.buf[this.offset + n] = t
    }
    : function(t) {
        this.buf[this.offset] = t
    }
    ;
    s && Object.defineProperty(t, n, {
        get: a,
        set: i,
        enumerable: !0
    }),
    Object.defineProperty(t, e, {
        get: a,
        set: i,
        enumerable: !0
    })
}
  , Ie = Math.abs
  , Be = (Math.max,
(t, e, n=1e-6) => Ie(t - e) <= n)
  , _e = t => je.add(t, pe(t, [Be, 1e-6], ( ([t,e]) => `eq(${t},${e},eps)`), "eq,_eps", "a,b,eps=_eps", "a,b", "", "&&", "return a.length === b.length && ", ";"))
  , je = oe();
je.default(( (t, e, n=1e-6) => xt(t, "eqDelta") ? t.eqDelta(e, n) : xt(e, "eqDelta") ? e.eqDelta(t, n) : De(t, e, t.length, n)));
_e(2),
_e(3);
const Fe = _e(4)
  , De = (t, e, n, r=1e-6, s=0, a=0, i=1, o=1) => {
    for (; n > 0; n--,
    s += i,
    a += o)
        if (!Be(t[s], e[a], r))
            return !1;
    return !0
}
;
const Ce = t => Le.add(t, me(t, ( ([t]) => `${t}*${t}`), "a", "a", "", "+", "return ", ";"))
  , Le = oe();
Le.default(ye(( ([t]) => `sum+=${t}*${t};`), "a", void 0, "sum", "let sum=0;"));
Ce(2),
Ce(3),
Ce(4);
const [Pe,qe,We,Te] = we((t => ([e,n]) => `${e}=${n}${t}n;`)("*"), "o,a,n");
const [Ve,He,Ke,Ye] = we(( ([t,e]) => `${t}=${e};`), "o,a", void 0, "o", 1, "!o&&(o=[]);")
  , Je = (t, e, n=1) => {
    !t && (t = e);
    const r = (t => Math.sqrt(Le(t)))(e);
    return r >= 1e-6 ? Pe(t, e, n / r) : t !== e ? Ve(t, e) : t
}
  , [Ze,Qe,Xe,tn] = Ae(i, ( ([t]) => `${t}=rnd.minmax(n,m);`), "a,n=-1,m=1,rnd=op", "a", "a", 0, "!a&&(a=[]);")
  , [en,nn,rn,sn] = Ae(( (t=i, e=0, n=1) => {
    let r, s, a;
    return () => {
        if (null != r)
            s = r,
            r = null;
        else
            do {
                r = t.norm(),
                s = t.norm(),
                a = r * r + s * s
            } while (a > 1 || 0 === a);
        return e + n * s * Math.sqrt(-2 * Math.log(a) / a)
    }
}
), ( ([t]) => `${t}=rnd()*n;`), "a,rnd=op(),n=1", "a", "a", 0, "!a&&(a=[]);")
  , an = t => (e, n=1, r=i) => Je(null, t(e, -1, 1, r), n)
  , on = t => (e, n, r=1) => Je(null, t(e, n), r)
  , [ln,hn,cn,fn] = (an(Ze),
an(Qe),
an(Xe),
an(tn),
on(en),
on(nn),
on(rn),
on(sn),
Ae(i, ( ([t,e,n]) => `${t}=rnd.minmax(${e},${n});`), "o,a,b,rnd=op", "o,a,b"))
  , un = {}
  , dn = (t, e) => {
    for (let t in e) {
        const n = e[t];
        if (C(n)) {
            const [r,s,a,i] = n;
            e[t] = 2 === n.length ? (t, e) => s(t, r(t, e)) : 3 === n.length ? (t, e) => a(t, s(t, r(t, e))) : (t, e) => i(t, a(t, s(t, r(t, e))))
        }
    }
    un[t] = {
        ...un[t],
        ...e
    }
}
  , gn = t => t <= .0031308 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - .055
  , bn = t => t <= .04045 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4)
  , mn = (t, e) => S(t || e, bn(e[0]), bn(e[1]), bn(e[2]), O(e[3]))
  , pn = (t, e) => mn(null, ut(t, e))
  , yn = t => {
    const e = t.channels || {}
      , n = t.order
      , s = n.length;
    n.reduce(( (t, n) => (t[n] = {
        range: [0, 1],
        ...e[n]
    },
    t)), e);
    const a = n.map((t => e[t].range[0]))
      , i = n.map((t => e[t].range[1]))
      , o = Ye([], a)
      , l = Ye([], i);
    o[s - 1] = 1;
    const h = class {
        constructor(t, e=0, n=1) {
            this.offset = e,
            this.stride = n,
            this.buf = t || [0, 0, 0, 0],
            this.offset = e,
            this.stride = n
        }
        get mode() {
            return t.mode
        }
        get length() {
            return s
        }
        get range() {
            return [a, i]
        }
        get[Symbol.toStringTag]() {
            return t.mode
        }
        [Symbol.iterator]() {
            return function*(t, e, n, r) {
                for (; e-- > 0; )
                    yield t[n],
                    n += r
            }(this.buf, this.length, this.offset, this.stride)
        }
        copy() {
            return new h(this.deref())
        }
        copyView() {
            return new h(this.buf,this.offset,this.stride)
        }
        empty() {
            return new h
        }
        deref() {
            return [this[0], this[1], this[2], this[3]]
        }
        set(t) {
            return Ye(this, t)
        }
        clamp() {
            return Ue(null, this, a, i)
        }
        eqDelta(t, e=1e-6) {
            return Fe(this, t, e)
        }
        randomize(t) {
            return ln(this, o, l, t)
        }
        toJSON() {
            return this.deref()
        }
        toString() {
            return Ut(4, 4)(this)
        }
    }
    ;
    var c, f, u;
    c = h.prototype,
    n.forEach(( (t, e) => Ge(c, t, e, f, u))),
    dn(t.mode, t.from),
    dn("rgb", {
        [t.mode]: t.toRgb
    });
    const g = (e, n, s) => {
        const a = new h(...s);
        return n !== t.mode ? ( (t, e, n, s) => {
            const a = un[n];
            r(!!a, `no conversions available for ${n}`);
            let i = a[s];
            return i ? i(t, e) : un.rgb[s] ? a.rgb(t, un.rgb[s]([], e)) : d(`can't convert: ${s} -> ${n}`)
        }
        )(a, e, t.mode, n) : a.set(e)
    }
      , b = (e, ...n) => null == e ? new h : P(e) ? b(gt(e), ...n) : vt(e) ? P(e.mode) ? g(e, e.mode, n) : new h(e,...n) : xt(e, "deref") ? g(e.deref(), e.mode, n) : L(e) ? n.length && n.every(L) ? new h(...(t => {
        if ("number" == typeof t[0])
            switch (t.length) {
            case 1:
                return t.push(0, 0, 1),
                [t];
            case 2:
                return t.push(0, 1),
                [t];
            case 3:
                return t.push(1),
                [t];
            default:
                return [t]
            }
        return t
    }
    )([e, ...n])) : g(pn([], e), "rgb", n) : W(`can't create a ${t.mode} color from: ${e}`);
    return b.class = h,
    b.range = [a, i],
    b.random = (t, e, n, r) => new h(e,n,r).randomize(t),
    b.mapBuffer = (t, e=t.length / s | 0, n=0, r=1, a=s) => Ot(h, t, e, n, r, a),
    b
}
  , wn = t => t > .00885645 ? Math.cbrt(t) : 7.787037 * t + 16 / 116
  , An = (t, e, n=ct) => {
    const r = wn(e[0] / n[0])
      , s = wn(e[1] / n[1])
      , a = wn(e[2] / n[2]);
    return S(t || e, 1.16 * s - .16, 5 * (r - s), 2 * (s - a), O(e[3]))
}
  , $n = t => me(t, ce, "o,a,io=0,ia=0,so=1,sa=1", "o,a", "", "+", "return ", ";", !0)
  , xn = ($n(2),
$n(3))
  , vn = ($n(4),
(t, e, n, r=!1) => {
    const s = xn(e, n, 0, 0, 3)
      , a = xn(e, n, 1, 0, 3)
      , i = xn(e, n, 2, 0, 3)
      , o = O(n[3]);
    return r ? S(t || n, v(s), v(a), v(i), o) : S(t || n, s, a, i, o)
}
)
  , Un = (t, e) => vn(t, ht, e)
  , Rn = t => {
    const e = t ** 3;
    return e > .008856 ? e : (t - 16 / 116) / 7.787
}
  , En = (t, e, n=ct) => {
    const r = (e[0] + .16) / 1.16;
    return S(t || e, Rn(e[1] / 5 + r) * n[0], Rn(r) * n[1], Rn(r - e[2] / 2) * n[2], O(e[3]))
}
  , zn = (t, e) => En(t, e, ft)
  , Mn = t => (t %= R) < 0 ? R + t : t
  , kn = (t, e) => {
    const {1: n, 2: r} = e;
    return S(t || e, e[0], Math.hypot(n, r), 0 === n && 0 === r ? 0 : (s = r,
    a = n,
    Mn(Math.atan2(s, a)) * E), O(e[3]));
    var s, a
}
  , Sn = (t, e) => {
    let {1: n, 2: r} = e;
    r *= R;
    const s = O(e[3]);
    return n > 0 ? S(t || e, e[0], Math.cos(r) * n, Math.sin(r) * n, s) : S(t || e, e[0], 0, 0, s)
}
  , On = (t, e, n=ot) => vn(t, n, e)
  , Nn = (t, e) => On(t, e, lt)
  , Gn = (t, e) => On(null, En(t, e))
  , In = (t, e, n=1) => S(t || e, v(e[0]), v(e[1]), v(e[2]), O(e[3], n))
  , Bn = (t, e, n=1) => S(t || e, M(e[0]), v(e[1]), v(e[2]), O(e[3], n))
  , _n = (t, e, n=it) => vn(null, n, In(t, e))
  , jn = yn({
    mode: "lch",
    channels: {
        c: {
            range: [0, 1.312]
        }
    },
    order: ["l", "c", "h", "alpha"],
    from: {
        rgb: (t, e) => kn(null, ( (t, e) => An(null, _n(t, e)))(t, e)),
        lab50: kn,
        lab65: [ (t, e) => An(t, Un(t, zn(t, e))), kn],
        xyz50: [An, kn],
        xyz65: [Un, An, kn]
    },
    toRgb: [Sn, Gn]
})
  , Fn = t => Dn.add(t, me(t, ce, "a,b", void 0, "", "+", "return ", ";"))
  , Dn = oe();
Dn.default(ye(( ([t,e]) => `s+=${t}*${e};`), "a,b", void 0, "s", "let s=0;"));
Fn(2);
const Cn = Fn(3)
  , Ln = (Fn(4),
(t, e, n=1) => (e = 6 * M(e),
S(t || [], v(Math.abs(e - 3) - 1), v(2 - Math.abs(e - 2)), v(2 - Math.abs(e - 4)), n)))
  , Pn = (t, e) => {
    const n = e[0];
    let r = e[1];
    const s = e[2]
      , a = Ln(t || e, n, O(e[3]))
      , i = ( (t, e=at) => Cn(t, e))(a);
    return s < i ? r *= s / i : i < 1 && (r *= (1 - s) / (1 - i)),
    k(a, v((a[0] - i) * r + s), v((a[1] - i) * r + s), v((a[2] - i) * r + s))
}
  , qn = (t, e) => {
    const n = (t = Bn(t || e, e))[1]
      , r = t[2];
    if (n < 1e-6)
        return k(t, r, r, r);
    const s = 6 * t[0] % 6
      , a = r * (1 - n)
      , i = 1 - Math.abs(s % 2 - 1);
    let o = 3 * r * n / (1 + i);
    const l = o * i + a;
    switch (o += a,
    0 | s) {
    case 0:
        return k(t, o, l, a);
    case 1:
        return k(t, l, o, a);
    case 2:
        return k(t, a, o, l);
    case 3:
        return k(t, a, l, o);
    case 4:
        return k(t, l, a, o);
    case 5:
        return k(t, o, a, l);
    default:
        return k(t, a, a, a)
    }
}
  , Wn = (t, e) => {
    const n = v(e[1])
      , r = v(e[2]);
    t = Ln(t || e, e[0], O(e[3]));
    const s = (1 - Math.abs(2 * r - 1)) * n;
    return k(t, (t[0] - .5) * s + r, (t[1] - .5) * s + r, (t[2] - .5) * s + r)
}
  , Tn = (t, e) => {
    const n = (t = Bn(t || e, e))[1]
      , r = t[2];
    return Ln(t, e[0], t[3]),
    k(t, ((t[0] - 1) * n + 1) * r, ((t[1] - 1) * n + 1) * r, ((t[2] - 1) * n + 1) * r)
}
  , Vn = [4.0767245293, -1.2681437731, -.0041119885, -3.3072168827, 2.6093323231, -.7034763098, .2307590544, -.341134429, 1.7068625689]
  , Hn = (t, e) => 0 !== e ? t / e : 0
  , Kn = yn({
    mode: "rgb",
    order: ["r", "g", "b", "alpha"],
    from: {
        abgr32: (t, e) => ( (t, e) => mn(null, dt(t, e)))(t, e[0]),
        argb32: (t, e) => pn(t, e[0]),
        hcy: Pn,
        hsi: qn,
        hsl: Wn,
        hsv: Tn,
        lab50: Gn,
        lab65: (t, e) => Nn(null, zn(t, e)),
        lch: [Sn, Gn],
        oklab: (t, {0: e, 1: n, 2: r, 3: s}) => vn(t, Vn, [(e + .3963377774 * n + .2158037573 * r) ** 3, (e - .1055613458 * n - .0638541728 * r) ** 3, (e - .0894841775 * n - 1.291485548 * r) ** 3, s]),
        rgb: Ye,
        srgb: mn,
        xyy: [ (t, e) => {
            const {0: n, 1: r, 2: s} = e;
            return S(t || e, Hn(s * n, r), s, Hn(s * (1 - n - r), r), O(e[3]))
        }
        , Nn],
        xyz50: On,
        xyz65: Nn,
        ycc: (t, e, n=at) => {
            const r = e[0]
              , s = (2 - 2 * n[2]) * e[1]
              , a = (2 - 2 * n[0]) * e[2];
            return S(t || e, r + a, r - n[2] / n[1] * s - n[0] / n[1] * a, r + s, O(e[3]))
        }
    },
    toRgb: Ye
})
  , Yn = (t, e=.00390625) => t[2] <= e
  , Jn = (t, e=.00390625) => t[0] <= e && t[1] <= e && t[2] <= e
  , Zn = (t, e=.00390625) => t[0] <= e
  , Qn = y((t => t.mode), {}, {
    hcy: Yn,
    hsi: Yn,
    hsl: Yn,
    hsv: Yn,
    labD50: Zn,
    labD65: Zn,
    lch: Zn,
    rgb: Jn,
    ycc: Jn,
    [p]: t => Jn(Kn(t))
})
  , Xn = (t, e=.00390625) => t[1] <= e
  , tr = (t, e=.00390625) => Be(t[0], t[1], e) && Be(t[0], t[2], e)
  , er = (t, e=.00390625) => Be(t[1], 0, e) && Be(t[2], 0, e)
  , nr = y((t => t.mode), {}, {
    hcy: Xn,
    hsi: Xn,
    hsl: Xn,
    hsv: Xn,
    labD50: er,
    labD65: er,
    lch: Xn,
    rgb: tr,
    srgb: tr,
    ycc: er,
    [p]: t => tr(Kn(t))
})
  , rr = (t, e=.00390625) => t[1] <= e && t[2] >= 1 - e
  , sr = (t, e=.00390625) => (e = 1 - e,
t[0] >= e && t[1] >= e && t[2] >= e)
  , ar = (t, e=.00390625) => t[1] <= e && t[0] >= 1 - e
  , ir = y((t => t.mode), {}, {
    hcy: (t, e=.00390625) => t[1] <= e && t[2] >= 1 - e,
    hsi: rr,
    hsl: rr,
    hsv: rr,
    labD50: ar,
    labD65: ar,
    lch: ar,
    rgb: sr,
    ycc: ar,
    [p]: t => sr(Kn(t))
})
  , or = {
    light: {
        c: [[.3, .7]],
        l: [[.9, 1]],
        b: [[.35, .5]],
        w: [[.6, 1]]
    },
    dark: {
        c: [[.7, 1]],
        l: [[.15, .4]],
        b: [[0, .4]],
        w: [[.4, .6]]
    },
    bright: {
        c: [[.75, .95]],
        l: [[.8, 1]]
    },
    weak: {
        c: [[.15, .3]],
        l: [[.7, 1]],
        b: [[.4, .6]],
        w: [[.8, 1]]
    },
    neutral: {
        c: [[.25, .35]],
        l: [[.3, .7]],
        b: [[.25, .4]],
        w: [[.9, 1]]
    },
    fresh: {
        c: [[.4, .8]],
        l: [[.8, 1]],
        b: [[.05, .3]],
        w: [[.8, 1]]
    },
    soft: {
        c: [[.2, .3]],
        l: [[.6, .9]],
        b: [[.05, .15]],
        w: [[.6, .9]]
    },
    hard: {
        c: [[.85, .95]],
        l: [[.4, 1]]
    },
    warm: {
        c: [[.6, .9]],
        l: [[.4, .9]],
        b: [[.2, .3]],
        w: [[.8, 1]]
    },
    cool: {
        c: [[.05, .2]],
        l: [[.9, 1]],
        b: [[0, .95]],
        w: [[.95, 1]]
    },
    intense: {
        c: [[.9, 1]],
        l: [[.2, .35], [.8, 1]]
    }
}
  , lr = [[0, 1]]
  , hr = {
    h: lr,
    c: lr,
    l: lr,
    b: lr,
    w: lr,
    a: [[1, 1]]
}
  , cr = {
    num: 1 / 0,
    variance: .025,
    eps: .001,
    rnd: i
}
  , fr = (t, e) => e.minmax(...t[e.int() % t.length])
  , ur = (t, e) => {
    t = {
        ...hr,
        ...P(t) ? or[t] : t
    };
    const {base: n, variance: r, rnd: s, eps: a} = {
        ...cr,
        ...e
    };
    let i, o, l, h;
    if (n) {
        const e = jn(n);
        i = e[2],
        h = O(e[3]),
        Qn(e, a) ? (o = 0,
        l = fr(t.b, s)) : ir(e, a) ? (o = 0,
        l = fr(t.w, s)) : nr(e, a) ? (o = 0,
        l = fr(T(s) ? t.b : t.w, s)) : i = M(i + s.norm(r))
    } else
        i = fr(t.h, s),
        h = fr(t.a, s);
    return jn([null != l ? l : fr(t.l, s), void 0 !== o ? o : fr(t.c, s), i, h])
}
;
const dr = (t, e=0) => 255 * (t < 0 ? 0 : t > 1 ? 1 : t) + .5 << e
  , gr = yn({
    mode: "srgb",
    order: ["r", "g", "b", "alpha"],
    from: {
        abgr32: (t, e) => dt(t, e[0]),
        argb32: (t, e) => ut(t, e[0]),
        hcy: Pn,
        hsi: qn,
        hsl: Wn,
        hsv: Tn,
        rgb: (t, e) => S(t || e, gn(e[0]), gn(e[1]), gn(e[2]), O(e[3]))
    },
    toRgb: mn
})
  , br = t => (255 * O(t[3]) + .5 << 24 | 255 * v(t[0]) + .5 << 16 | 255 * v(t[1]) + .5 << 8 | 255 * v(t[2]) + .5) >>> 0;
class mr {
    constructor(t, e=0, n=1) {
        this.offset = e,
        this.stride = n,
        this.buf = t || [0]
    }
    eqDelta(t, e) {
        return Fe(ut([], this[0]), ut([], t[0]), e)
    }
    get length() {
        return 1
    }
    get range() {
        return [[0], [4294967295]]
    }
    get alpha() {
        return (this[0] >>> 24) / 255
    }
    set alpha(t) {
        this[0] = 16777215 & this[0] | dr(t, 24)
    }
    *[Symbol.iterator]() {
        yield this[0]
    }
    deref() {
        return [this[0]]
    }
    randomize(t=i) {
        const e = this[0];
        return this[0] = 4278190080 & e | 16777215 & t.int(),
        this
    }
    clamp() {
        return this
    }
    set(t) {
        return this[0] = t[0],
        this
    }
    toJSON() {
        return [this[0]]
    }
}
class pr extends mr {
    get mode() {
        return "argb32"
    }
    get r() {
        return (this[0] >> 16 & 255) / 255
    }
    set r(t) {
        this[0] = 4278255615 & this[0] | dr(t, 16)
    }
    get g() {
        return (this[0] >> 8 & 255) / 255
    }
    set g(t) {
        this[0] = 4294902015 & this[0] | dr(t, 8)
    }
    get b() {
        return (255 & this[0]) / 255
    }
    set b(t) {
        this[0] = 4294967040 & this[0] | dr(t)
    }
    copy() {
        return new pr([this[0]])
    }
    copyView() {
        return new pr(this.buf,this.offset,this.stride)
    }
    empty() {
        return new pr
    }
}
Ge(pr.prototype, "value", 0);
class yr extends mr {
    get mode() {
        return "abgr32"
    }
    get r() {
        return (255 & this[0]) / 255
    }
    set r(t) {
        this[0] = 4294967040 & this[0] | dr(t)
    }
    get g() {
        return (this[0] >> 8 & 255) / 255
    }
    set g(t) {
        this[0] = 4294902015 & this[0] | dr(t, 8)
    }
    get b() {
        return (this[0] >> 16 & 255) / 255
    }
    set b(t) {
        this[0] = 4278255615 & this[0] | dr(t, 16)
    }
    copy() {
        return new yr([this[0]])
    }
    copyView() {
        return new yr(this.buf,this.offset,this.stride)
    }
    empty() {
        return new yr
    }
}
Ge(yr.prototype, "value", 0);
const wr = (t, e) => {
    const n = (r, ...s) => null == r ? new t : L(r) ? s.length && s.every(L) ? new t([br([r, ...s])]) : new t([r],...s) : P(r) ? n(gt(r)) : vt(r) ? P(r.mode) ? new t([e(gr(r))],...s) : new t(r,...s) : xt(r, "deref") ? new t([e(gr(r))],...s) : W(`can't create a ARGB32 color from: ${r}`);
    return n.class = t,
    n.range = [[0], [4294967295]],
    n.random = (e=i, n, r, s) => new t(n,r,s).set([16777215 & e.int() | 4278190080]),
    n.mapBuffer = (e, n=e.length, r=0, s=1, a=1) => Ot(t, e, n, r, s, a),
    n
}
  , Ar = (wr(pr, br),
wr(yr, (t => (255 * O(t[3]) + .5 << 24 | 255 * v(t[2]) + .5 << 16 | 255 * v(t[1]) + .5 << 8 | 255 * v(t[0]) + .5) >>> 0)))
  , $r = (t, e) => (t = ( (t, e) => {
    const n = (t = In(t || e, e))[1] < t[2] ? [t[2], t[1], -1, 2 / 3] : [t[1], t[2], 0, -1 / 3]
      , r = t[0] < n[0] ? [n[0], n[1], n[3], t[0]] : [t[0], n[1], n[2], n[0]]
      , s = r[0] - Math.min(r[1], r[3]);
    return k(t, v(Math.abs((r[3] - r[1]) / (6 * s + 1e-6) + r[2])), v(s), v(r[0]))
}
)(t, e),
t[1] /= t[2] + 1e-6,
t)
  , xr = yn({
    mode: "hsv",
    order: ["h", "s", "v", "alpha"],
    from: {
        rgb: $r,
        srgb: $r,
        hsl: (t, e) => {
            const n = (t = Bn(t || e, e))[1]
              , r = t[2]
              , s = 2 * r
              , a = .5 * (s + n * (1 - Math.abs(s - 1)));
            return t[1] = 2 * (a - r) / a,
            t[2] = a,
            t
        }
    },
    toRgb: Tn
})
  , vr = t => Math.round(12 * M(t)) % 12
  , Ur = t => "function" == typeof t ? t : e => e[t];
const Rr = (t, e) => t - e
  , Er = (t, e) => e - t
  , zr = (t, e) => t + --e & ~e
  , Mr = t => new Array(t).fill(0).map(( (e, n) => 1 << t - 1 - n))
  , kr = (Mr(8),
Mr(16),
Mr(32),
new Array(33).fill(0).map(( (t, e) => Math.pow(2, e) - 1)),
t => ~t)
  , Sr = (t, e) => t & e
  , Or = (t, e) => t | e
  , Nr = (t, e) => t ^ e
  , Gr = t => 16843009 * ((t = (858993459 & (t -= t >>> 1 & 1431655765)) + (t >>> 2 & 858993459)) + (t >>> 4) & 252645135) >>> 24
  , Ir = Q(( (t, e, n="") => {
    const r = X("0", e);
    return s => (s = (s >>> 0).toString(t),
    n + (s.length < e ? r.substr(s.length) + s : s))
}
))
  , Br = (Ir(2, 8),
Ir(2, 16),
Ir(2, 32));
class _r {
    constructor(t) {
        const e = "number" == typeof t;
        this.n = zr(e ? t : t.length, 32),
        this.data = new Uint32Array(this.n >>> 5),
        !e && this.setRange(0, t)
    }
    clear() {
        this.data.fill(0)
    }
    copy() {
        const t = new _r(this.n);
        return t.data.set(this.data),
        t
    }
    resize(t) {
        if ((t = zr(t, 32)) === this.n)
            return this;
        const e = new Uint32Array(t >>> 5);
        return e.set(this.data.slice(0, e.length)),
        this.data = e,
        this.n = t,
        this
    }
    at(t) {
        return this.data[t >>> 5] & 1 << (31 & ~t)
    }
    setAt(t, e=!0) {
        const n = t >>> 5
          , r = 1 << (31 & ~t)
          , s = this.data[n] & r;
        return e ? this.data[n] |= r : this.data[n] &= ~r,
        s
    }
    setRange(t, e) {
        const n = "string" == typeof e;
        for (let r = 0, s = Math.min(this.n, r + e.length); r < s; r++)
            this.setAt(t + r, n ? "1" === e[r] : e[r])
    }
    toggleAt(t) {
        const e = t >>> 5
          , n = 1 << (31 & ~t)
          , r = this.data[e] & n;
        return r ? this.data[e] &= ~n : this.data[e] |= n,
        r
    }
    popCount() {
        return ( (t, e=0, n=t.length) => {
            let r = 0;
            for (let s = e + n; e < s; e++) {
                const n = t[e];
                n > 0 && (r += Gr(n))
            }
            return r
        }
        )(this.data)
    }
    and(t) {
        return this.binOp(t, Sr)
    }
    or(t) {
        return this.binOp(t, Or)
    }
    xor(t) {
        return this.binOp(t, Nr)
    }
    not() {
        return this.binOp(this, kr)
    }
    toString() {
        return t = this.data,
        [...t].map(Br).join("");
        var t
    }
    binOp(t, e) {
        return this.ensureSize(t),
        ( (t, e, n) => {
            for (let r = e.length; r-- > 0; )
                t[r] = n(e[r], t[r])
        }
        )(this.data, t.data, e),
        this
    }
    ensureSize(t) {
        r(t.n === this.n, "fields must be same size")
    }
}
function *jr(t, e, n, r, s) {
    if (!t(e |= 0, n |= 0))
        return;
    const a = [[e, n]]
      , i = new _r(r * s);
    for (s--; a.length; )
        [e,n] = a.pop(),
        yield*Fr(t, a, i, e, n, r, s, -1),
        yield*Fr(t, a, i, e + 1, n, r, s, 1)
}
function *Fr(t, e, n, r, s, a, i, o) {
    let l = s * a + r;
    if (n.at(l))
        return;
    let h = !1
      , c = !1;
    for (; r >= 0 && r < a && t(r, s); )
        n.setAt(l),
        yield[r, s],
        s > 0 && (t(r, s - 1) && !h ? (e.push([r, s - 1]),
        h = !0) : h = !1),
        s < i && (t(r, s + 1) && !c ? (e.push([r, s + 1]),
        c = !0) : c = !1),
        r += o,
        l += o
}
const Dr = (t, e, n, r, s, a) => {
    const i = 1 - s
      , o = 1 - a;
    return t * i * o + e * s * o + n * i * a + r * s * a
}
  , Cr = (t, e, n, r, s) => {
    const a = s * s;
    return s * a * (-.5 * t + 1.5 * e - 1.5 * n + (r *= .5)) + a * (t - 2.5 * e + 2 * n - r) + s * (-.5 * t + .5 * n) + e
}
  , Lr = (t, e, n, r, s, a, i, o, l, h, c, f, u, d, g, b, m, p) => Cr(Cr(t, e, n, r, m), Cr(s, a, i, o, m), Cr(l, h, c, f, m), Cr(u, d, g, b, m), p)
  , Pr = (t, e) => Math.floor(e * t) / t
  , qr = (t, e=t, n) => {
    const r = document.createElement("canvas");
    return r.width = t,
    r.height = e,
    n && n.appendChild(r),
    {
        canvas: r,
        ctx: r.getContext("2d")
    }
}
;
var Wr, Tr;
(Tr = Wr || (Wr = {}))[Tr.ALPHA = 0] = "ALPHA",
Tr[Tr.BLUE = 1] = "BLUE",
Tr[Tr.GREEN = 2] = "GREEN",
Tr[Tr.RED = 3] = "RED";
const Vr = t => (29 * (t >>> 16 & 255) + 150 * (t >>> 8 & 255) + 76 * (255 & t)) / 255
  , Hr = (t, e, n, r, s, a, i=0, o=0) => (n |= 0,
r |= 0,
(t |= 0) < 0 && (n += t,
i -= t,
t = 0),
(e |= 0) < 0 && (r += e,
o -= e,
e = 0),
[t, e, x(n, 0, s - t), x(r, 0, a - e), i, o])
  , Kr = (t, e, n={}) => {
    const r = t.width
      , s = e.width;
    let a, i, o, l, h, c;
    return [a,i,h,c] = Hr(n.sx || 0, n.sy || 0, n.w || r, n.h || t.height, r, t.height),
    [o,l,h,c,a,i] = Hr(n.dx || 0, n.dy || 0, h, c, s, e.height, a, i),
    {
        sx: a,
        sy: i,
        dx: o,
        dy: l,
        rw: h,
        rh: c
    }
}
  , Yr = (t, e, n) => {
    const r = e.fromABGR
      , s = e.toABGR;
    for (let e = t.length; e-- > 0; )
        t[e] = r(n(s(t[e])))
}
  , Jr = (t, e) => e > 0 ? `(${t} << ${e})` : e < 0 ? `(${t} >>> ${-e})` : `${t}`
  , Zr = (t, e) => Jr(t, -e)
  , Qr = t => `0x${t.toString(16)}`
  , Xr = t => {
    const e = (1 << t) - 1;
    return new Function("luma",`return (x) => ${Zr("luma(x)", 8 - t)} & ${e};`)(Vr)
}
  , ts = t => {
    let e;
    if (8 !== t) {
        const n = (1 << t) - 1;
        e = `(((x & ${n}) * ${255 / n}) | 0)`
    } else
        e = "x";
    return new Function("x",`return 0xff000000 | (${e} * 0x010101);`)
}
  , es = (t, e) => {
    const n = t.map((t => {
        if (8 !== t.size) {
            const e = t.mask0
              , n = 255 / e
              , r = Zr("x", t.shift);
            return Jr(`((${r} & ${e}) * ${n})`, 24 - 8 * t.lane)
        }
        return Jr(`(x & ${Qr(t.maskA)})`, t.abgrShift)
    }
    )).join(" | ");
    return new Function("x",`return (${e ? "" : "0xff000000 | "}${n}) >>> 0;`)
}
  , ns = t => {
    r(t.channels.length > 0, "no channel specs given");
    const e = t.channels.reduce(( ([t,e], n, r) => (e -= n.size,
    t.push(( (t, e, n) => {
        const r = 1 << t.size
          , s = r - 1
          , a = s << n >>> 0
          , i = ~a >>> 0
          , o = null != t.lane ? t.lane : e
          , l = t => t >>> n & s
          , h = (t, e) => t & i | (e & s) << n;
        return {
            size: t.size,
            num: r,
            abgrShift: 24 - 8 * o - n,
            lane: o,
            shift: n,
            mask0: s,
            maskA: a,
            int: l,
            setInt: h,
            float: t => l(t) / s,
            setFloat: (t, e) => h(t, v(e) * s)
        }
    }
    )(n, r, e)),
    [t, e])), [[], t.size])[0];
    return {
        __packed: !0,
        type: t.type,
        size: t.size,
        alpha: t.alpha || 0,
        channels: e,
        fromABGR: t.fromABGR || (n = e,
        new Function("x","return (" + n.map((t => {
            const e = t.abgrShift + (8 - t.size);
            return `(${Zr("x", e)} & ${Qr(t.maskA)})`
        }
        )).join(" | ") + ") >>> 0;")),
        toABGR: t.toABGR || es(e, !!t.alpha)
    };
    var n
}
  , rs = ns({
    type: "u32",
    size: 32,
    alpha: 8,
    channels: [{
        size: 8,
        lane: Wr.ALPHA
    }, {
        size: 8,
        lane: Wr.BLUE
    }, {
        size: 8,
        lane: Wr.GREEN
    }, {
        size: 8,
        lane: Wr.RED
    }],
    fromABGR: t => t,
    toABGR: t => t
});
Object.create;
Object.create;
const ss = (t, e={}) => {
    const n = Reflect.ownKeys(t)
      , r = Reflect.ownKeys(e)
      , s = Symbol("isa");
    function a(e) {
        for (let r of n) {
            const n = Object.getOwnPropertyDescriptor(e.prototype, r);
            n && !n.configurable || Object.defineProperty(e.prototype, r, {
                value: t[r],
                writable: !0
            })
        }
        return Object.defineProperty(e.prototype, s, {
            value: !0
        }),
        e
    }
    for (let t of r)
        Object.defineProperty(a, t, {
            value: e[t],
            enumerable: e.propertyIsEnumerable(t)
        });
    return Object.defineProperty(a, Symbol.hasInstance, {
        value: t => !!t[s]
    }),
    a
}
  , as = (ss({
    order: () => [0],
    includes(t) {
        return t >= 0 && t < this.size[0]
    },
    indexAt(t) {
        return this.includes(t) ? this.indexAtUnsafe(t) : -1
    },
    indexAtUnsafe(t) {
        return this.offset + (0 | t) * this.stride[0]
    },
    getAt(t) {
        return this.includes(t) ? this.data[this.indexAtUnsafe(t)] : 0
    },
    getAtUnsafe(t) {
        return this.data[this.indexAtUnsafe(t)]
    },
    setAt(t, e) {
        return !!this.includes(t) && (this.data[this.indexAtUnsafe(t)] = e,
        !0)
    },
    setAtUnsafe(t, e) {
        return this.data[this.indexAtUnsafe(t)] = e,
        !0
    }
}),
ss({
    order() {
        return Math.abs(this.stride[1]) > Math.abs(this.stride[0]) ? [1, 0] : [0, 1]
    },
    includes(t, e) {
        const n = this.size;
        return t >= 0 && t < n[0] && e >= 0 && e < n[1]
    },
    indexAt(t, e) {
        return this.includes(t, e) ? this.indexAtUnsafe(t, e) : -1
    },
    indexAtUnsafe(t, e) {
        return this.offset + (0 | t) * this.stride[0] + (0 | e) * this.stride[1]
    },
    getAt(t, e) {
        return this.includes(t, e) ? this.data[this.indexAtUnsafe(t, e)] : 0
    },
    getAtUnsafe(t, e) {
        return this.data[this.indexAtUnsafe(t, e)]
    },
    setAt(t, e, n) {
        return !!this.includes(t, e) && (this.data[this.indexAtUnsafe(t, e)] = n,
        !0)
    },
    setAtUnsafe(t, e, n) {
        return this.data[this.indexAtUnsafe(t, e)] = n,
        !0
    }
}))
  , is = (ss({
    order() {
        return is(this.stride)
    },
    includes(t, e, n) {
        const r = this.size;
        return t >= 0 && t < r[0] && e >= 0 && e < r[1] && n >= 0 && n < r[2]
    },
    indexAt(t, e, n) {
        return this.includes(t, e, n) ? this.indexAtUnsafe(t, e, n) : -1
    },
    indexAtUnsafe(t, e, n) {
        const r = this.stride;
        return this.offset + (0 | t) * r[0] + (0 | e) * r[1] + (0 | n) * r[2]
    },
    getAt(t, e, n) {
        return this.includes(t, e, n) ? this.data[this.indexAtUnsafe(t, e, n)] : 0
    },
    getAtUnsafe(t, e, n) {
        return this.data[this.indexAtUnsafe(t, e, n)]
    },
    setAt(t, e, n, r) {
        return !!this.includes(t, e, n) && (this.data[this.indexAtUnsafe(t, e, n)] = r,
        !0)
    },
    setAtUnsafe(t, e, n, r) {
        return this.data[this.indexAtUnsafe(t, e, n)] = r,
        !0
    }
}),
ss({
    order() {
        return is(this.stride)
    },
    includes(t, e, n, r) {
        const s = this.size;
        return t >= 0 && t < s[0] && e >= 0 && e < s[1] && n >= 0 && n < s[2] && r >= 0 && r < s[3]
    },
    indexAt(t, e, n, r) {
        return this.includes(t, e, n, r) ? this.indexAtUnsafe(t, e, n, r) : -1
    },
    indexAtUnsafe(t, e, n, r) {
        const s = this.stride;
        return this.offset + (0 | t) * s[0] + (0 | e) * s[1] + (0 | n) * s[2] + (0 | r) * s[3]
    },
    getAt(t, e, n, r) {
        return this.includes(t, e, n, r) ? this.data[this.indexAtUnsafe(t, e, n, r)] : 0
    },
    getAtUnsafe(t, e, n, r) {
        return this.data[this.indexAtUnsafe(t, e, n, r)]
    },
    setAt(t, e, n, r, s) {
        return !!this.includes(t, e, n, r) && (this.data[this.indexAtUnsafe(t, e, n, r)] = s,
        !0)
    },
    setAtUnsafe(t, e, n, r, s) {
        return this.data[this.indexAtUnsafe(t, e, n, r)] = s,
        !0
    }
}),
t => [...t].map(( (t, e) => [t, e])).sort(( (t, e) => Math.abs(e[0]) - Math.abs(t[0]))).map((t => t[1])))
  , os = t => {
    const e = (t >>> 24) / 255;
    return 4278190080 & t | (t >>> 16 & 255) * e << 16 | (t >>> 8 & 255) * e << 8 | (255 & t) * e
}
  , ls = t => {
    const e = (t >>> 24) / 255;
    return e > 0 ? (4278190080 & t | Math.min(255, (t >>> 16 & 255) / e) << 16 | Math.min(255, (t >>> 8 & 255) / e) << 8 | Math.min(255, (255 & t) / e)) >>> 0 : t
}
  , hs = t => {
    const e = t >>> 24;
    return (t >>> 16 & 255) <= e && (t >>> 8 & 255) <= e && (255 & t) <= e
}
  , cs = (t, e) => {
    const n = t.channels[e];
    return r(null != n, `invalid channel ID: ${e}`),
    n
}
;
const fs = ({data: t, width: e, height: n}) => (r, s) => r >= 0 && r < e && s >= 0 && s < n ? t[(0 | s) * e + (0 | r)] : 0
  , us = ({data: t, width: e, height: n}) => (r, s) => t[z(0 | s, n) * e + z(0 | r, e)]
  , ds = ({data: t, width: e, height: n}) => {
    const r = e - 1
      , s = n - 1;
    return (n, a) => t[x(0 | a, 0, s) * e + x(0 | n, 0, r)]
}
  , gs = ({data: t, width: e, height: n, stride: [r,s]}) => (a, i) => {
    let o;
    return a >= 0 && a < e && i >= 0 && i < n ? (o = (0 | i) * s + (0 | a) * r,
    t.slice(o, o + r)) : [0]
}
  , bs = ({data: t, width: e, height: n, stride: [r,s]}) => (a, i) => {
    let o = z(0 | i, n) * s + z(0 | a, e) * r;
    return t.slice(o, o + r)
}
  , ms = ({data: t, width: e, height: n, stride: [r,s]}) => {
    const a = e - 1
      , i = n - 1;
    return (e, n) => {
        let o = x(0 | n, 0, i) * s + x(0 | e, 0, a) * r;
        return t.slice(o, o + r)
    }
}
  , ps = (t, e, n, r, s=4) => Dr(t[r], t[r + s], t[r + 2 * s], t[r + 3 * s], e, n)
  , ys = t => (e, n) => Dr(t(e -= .5, n -= .5), t(e + 1, n), t(e, n + 1), t(e + 1, n + 1), M(e), M(n))
  , ws = t => (t = ys(t),
(e, n) => [t(e, n)])
  , As = (t, e) => {
    const {fromABGR: n, toABGR: r} = t.format
      , s = new Uint32Array(4)
      , a = new Uint8Array(s.buffer);
    return (t, i) => {
        t -= .5,
        i -= .5,
        s[0] = r(e(t, i)),
        s[1] = r(e(t + 1, i)),
        s[2] = r(e(t, i + 1)),
        s[3] = r(e(t + 1, i + 1));
        const o = M(t)
          , l = M(i);
        return n(ps(a, o, l, 0) | ps(a, o, l, 1) << 8 | ps(a, o, l, 2) << 16 | ps(a, o, l, 3) << 24) >>> 0
    }
}
  , $s = ({stride: [t]}, e) => {
    const n = new Float32Array(4 * t);
    return (r, s) => {
        r -= .5,
        s -= .5,
        n.set(e(r, s), 0),
        n.set(e(r + 1, s), t),
        n.set(e(r, s + 1), 2 * t),
        n.set(e(r + 1, s + 1), 3 * t);
        const a = M(r)
          , i = M(s);
        let o = [];
        for (let e = 0; e < t; e++)
            o.push(ps(n, a, i, e, t));
        return o
    }
}
  , xs = t => (e, n) => {
    const r = (e -= .5) - 1
      , s = e + 1
      , a = e + 2
      , i = (n -= .5) - 1
      , o = n + 1
      , l = n + 2;
    return Lr(t(r, i), t(e, i), t(s, i), t(a, i), t(r, n), t(e, n), t(s, n), t(a, n), t(r, o), t(e, o), t(s, o), t(a, o), t(r, l), t(e, l), t(s, l), t(a, l), M(e), M(n))
}
  , vs = (t, e) => {
    const n = t.format.channels[0].mask0;
    return e = xs(e),
    (t, r) => x(e(t, r), 0, n)
}
  , Us = t => (t = xs(t),
(e, n) => [t(e, n)])
  , Rs = (t, e, n, r, s=4) => Lr(t[r], t[r + s], t[r + 2 * s], t[r + 3 * s], t[r + 4 * s], t[r + 5 * s], t[r + 6 * s], t[r + 7 * s], t[r + 8 * s], t[r + 9 * s], t[r + 10 * s], t[r + 11 * s], t[r + 12 * s], t[r + 13 * s], t[r + 14 * s], t[r + 15 * s], e, n)
  , Es = (t, e, n, r, s=4) => x(Rs(t, e, n, r, s), 0, 255)
  , zs = (t, e) => {
    const {fromABGR: n, toABGR: r} = t.format
      , s = new Uint32Array(16)
      , a = new Uint8Array(s.buffer);
    return (t, i) => {
        const o = (t -= .5) - 1
          , l = t + 1
          , h = t + 2
          , c = (i -= .5) - 1
          , f = i + 1
          , u = i + 2
          , d = M(t)
          , g = M(i);
        return s[0] = r(e(o, c)),
        s[1] = r(e(t, c)),
        s[2] = r(e(l, c)),
        s[3] = r(e(h, c)),
        s[4] = r(e(o, i)),
        s[5] = r(e(t, i)),
        s[6] = r(e(l, i)),
        s[7] = r(e(h, i)),
        s[8] = r(e(o, f)),
        s[9] = r(e(t, f)),
        s[10] = r(e(l, f)),
        s[11] = r(e(h, f)),
        s[12] = r(e(o, u)),
        s[13] = r(e(t, u)),
        s[14] = r(e(l, u)),
        s[15] = r(e(h, u)),
        n(Es(a, d, g, 0) | Es(a, d, g, 1) << 8 | Es(a, d, g, 2) << 16 | Es(a, d, g, 3) << 24) >>> 0
    }
}
  , Ms = ({stride: [t]}, e) => {
    const n = new Float32Array(16 * t);
    return (r, s) => {
        const a = (r -= .5) - 1
          , i = r + 1
          , o = r + 2
          , l = (s -= .5) - 1
          , h = s + 1
          , c = s + 2
          , f = M(r)
          , u = M(s);
        n.set(e(a, l), 0),
        n.set(e(r, l), t),
        n.set(e(i, l), 2 * t),
        n.set(e(o, l), 3 * t),
        n.set(e(a, s), 4 * t),
        n.set(e(r, s), 5 * t),
        n.set(e(i, s), 6 * t),
        n.set(e(o, s), 7 * t),
        n.set(e(a, h), 8 * t),
        n.set(e(r, h), 9 * t),
        n.set(e(i, h), 10 * t),
        n.set(e(o, h), 11 * t),
        n.set(e(a, c), 12 * t),
        n.set(e(r, c), 13 * t),
        n.set(e(i, c), 14 * t),
        n.set(e(o, c), 15 * t);
        let d = [];
        for (let e = 0; e < t; e++)
            d.push(Rs(n, f, u, e, t));
        return d
    }
}
;
var ks;
function Ss(...t) {
    return t[0]instanceof Ns ? t[0].as(t[1]) : new Ns(...t)
}
const Os = (t, e=rs) => {
    const n = function(t, e) {
        let n, r;
        if (L(t)) {
            const s = qr(t, e);
            n = s.canvas,
            r = s.ctx
        } else
            n = t,
            r = n.getContext("2d");
        const s = r.getImageData(0, 0, n.width, n.height);
        return {
            canvas: n,
            ctx: r,
            img: s,
            data: new Uint32Array(s.data.buffer)
        }
    }(t)
      , r = t.width
      , s = t.height;
    let a;
    if (e === rs)
        a = n.data;
    else {
        a = St(e.type, r * s);
        const t = n.data
          , i = e.fromABGR;
        for (let e = a.length; e-- > 0; )
            a[e] = i(t[e])
    }
    return new Ns(r,s,e,a)
}
;
let Ns = ks = class {
    constructor(t, e, n=rs, r) {
        this.size = [t, e],
        this.stride = [1, t],
        this.format = n.__packed ? n : ns(n),
        this.data = r || St(n.type, t * e)
    }
    get pixels() {
        return this.data
    }
    get width() {
        return this.size[0]
    }
    get height() {
        return this.size[1]
    }
    get offset() {
        return 0
    }
    get dim() {
        return 2
    }
    as(t) {
        return this.getRegion(0, 0, this.width, this.height, t)
    }
    copy() {
        const t = this.empty();
        return t.data.set(this.data),
        t
    }
    empty() {
        return new ks(this.width,this.height,this.format)
    }
    order() {}
    includes(t, e) {}
    indexAt(t, e) {}
    indexAtUnsafe(t, e) {}
    getAt(t, e) {}
    getAtUnsafe(t, e) {}
    setAt(t, e, n) {}
    setAtUnsafe(t, e, n) {}
    getChannelAt(t, e, n, r=!1) {
        const s = cs(this.format, n)
          , a = this.getAt(t, e);
        return r ? s.float(a) : s.int(a)
    }
    setChannelAt(t, e, n, r, s=!1) {
        const a = cs(this.format, n)
          , i = this.getAt(t, e);
        return s ? a.setFloat(i, r) : a.setInt(i, r),
        this
    }
    blend(t, e, n) {
        let r = this.width
          , s = e.width;
        const {sx: a, sy: i, dx: o, dy: l, rw: h, rh: c} = Kr(this, e, n);
        if (h < 1 || c < 1)
            return e;
        const f = this.data
          , u = e.data
          , d = this.format.toABGR
          , g = e.format.toABGR
          , b = e.format.fromABGR;
        for (let e = (0 | a) + (0 | i) * r, n = (0 | o) + (0 | l) * s, m = 0; m < c; m++,
        e += r,
        n += s)
            for (let r = 0; r < h; r++)
                u[n + r] = b(t(d(f[e + r]), g(u[n + r])));
        return e
    }
    blit(t, e) {
        let n = this.width
          , r = t.width;
        const {sx: s, sy: a, dx: i, dy: o, rw: l, rh: h} = Kr(this, t, e);
        if (l < 1 || h < 1)
            return t;
        const c = this.data
          , f = t.data
          , u = this.format.toABGR
          , d = t.format.fromABGR
          , g = this.format !== t.format ? (t, e) => {
            for (let n = 0; n < l; n++)
                f[e + n] = d(u(c[t + n]))
        }
        : (t, e) => f.set(c.subarray(t, t + l), e);
        for (let t = (0 | s) + (0 | a) * n, e = (0 | i) + (0 | o) * r, l = 0; l < h; l++,
        t += n,
        e += r)
            g(t, e);
        return t
    }
    blitCanvas(t, e=0, n=0) {
        (t instanceof HTMLCanvasElement ? t.getContext("2d") : t).putImageData(this.toImageData(), e, n)
    }
    toImageData() {
        const t = new ImageData(this.width,this.height)
          , e = new Uint32Array(t.data.buffer)
          , n = this.data
          , r = this.format.toABGR;
        for (let t = e.length; t-- > 0; )
            e[t] = r(n[t]);
        return t
    }
    getRegion(t, e, n, r, s) {
        const [a,i,o,l] = Hr(t, e, n, r, this.width, this.height);
        return this.blit(new ks(o,l,s || this.format), {
            sx: a,
            sy: i,
            w: o,
            h: l
        })
    }
    getChannel(t) {
        const e = cs(this.format, t)
          , n = new ks(this.width,this.height,{
            type: (r = e.size,
            r > 16 ? "u32" : r > 8 ? "u16" : "u8"),
            size: e.size,
            channels: [{
                size: e.size,
                lane: Wr.RED
            }],
            fromABGR: Xr(e.size),
            toABGR: ts(e.size)
        });
        var r;
        const s = this.data
          , a = n.data
          , i = e.int;
        for (let t = s.length; t-- > 0; )
            a[t] = i(s[t]);
        return n
    }
    setChannel(t, e) {
        const n = cs(this.format, t)
          , s = this.data
          , a = n.setInt;
        if (L(e))
            ( (t, e, n) => {
                for (let r = t.length; r-- > 0; )
                    t[r] = n(t[r], e)
            }
            )(s, e, a);
        else {
            const t = e.data
              , i = e.format.channels[0];
            ( (t, e, n, s=1) => {
                r(t.length >= e * n * s, "pixel buffer too small")
            }
            )(t, this.width, this.height),
            n.size === i.size ? ( (t, e, n, r) => {
                for (let s = t.length; s-- > 0; )
                    t[s] = r(t[s], n(e[s]))
            }
            )(s, t, i.int, a) : ( (t, e, n, r, s) => {
                const a = ~s;
                for (let i = t.length; i-- > 0; )
                    t[i] = t[i] & a | n(r(e[i])) & s
            }
            )(s, t, this.format.fromABGR, e.format.toABGR, n.maskA)
        }
        return this
    }
    invert() {
        const {data: t, format: e} = this
          , n = Math.pow(2, e.size - e.alpha) - 1;
        for (let e = t.length; e-- > 0; )
            t[e] ^= n;
        return this
    }
    premultiply() {
        return Yr(this.data, this.format, os),
        this
    }
    postmultiply() {
        return Yr(this.data, this.format, ls),
        this
    }
    isPremultiplied() {
        const t = this.data
          , e = this.format.toABGR;
        for (let n = t.length; n-- > 0; )
            if (!hs(e(t[n])))
                return !1;
        return !0
    }
    forEach(t) {
        const e = this.data;
        for (let n = e.length; n-- > 0; )
            e[n] = t(e[n], n);
        return this
    }
    flipY() {
        const {data: t, width: e} = this
          , n = St(this.format.type, e);
        for (let r = 0, s = t.length - e; r < s; r += e,
        s -= e)
            n.set(t.subarray(r, r + e)),
            t.copyWithin(r, s, s + e),
            t.set(n, s);
        return this
    }
    scale(t, e="linear") {
        return r(t > 0, "scale must be > 0"),
        this.resize(this.width * t, this.height * t, e)
    }
    resize(t, e, n="linear") {
        e |= 0,
        r((t |= 0) > 0 && e > 0, "target width & height must be > 0");
        const s = Ss(t, e, this.format)
          , a = s.data
          , i = t > 0 ? this.width / t : 0
          , o = e > 0 ? this.height / e : 0;
        n = P(n) ? function(t, e="linear", n="clamp") {
            const s = !!t.format.__float
              , a = 1 === t.format.channels.length ? "1" : ""
              , i = `${e[0]}${n[0]}${a}`
              , o = (s ? {
                nc1: gs,
                nw1: bs,
                nr1: ms,
                nc: gs,
                nw: bs,
                nr: ms,
                lc1: t => ws(fs(t)),
                lw1: t => ws(us(t)),
                lr1: t => ws(ds(t)),
                lc: t => $s(t, gs(t)),
                lw: t => $s(t, bs(t)),
                lr: t => $s(t, ms(t)),
                cc1: t => Us(fs(t)),
                cw1: t => Us(us(t)),
                cr1: t => Us(ds(t)),
                cc: t => Ms(t, gs(t)),
                cw: t => Ms(t, bs(t)),
                cr: t => Ms(t, ms(t))
            } : {
                nc1: fs,
                nw1: us,
                nr1: ds,
                nc: fs,
                nw: us,
                nr: ds,
                lc1: t => ys(fs(t)),
                lw1: t => ys(us(t)),
                lr1: t => ys(ds(t)),
                lc: t => As(t, fs(t)),
                lw: t => As(t, us(t)),
                lr: t => As(t, ds(t)),
                cc1: t => vs(t, fs(t)),
                cw1: t => vs(t, us(t)),
                cr1: t => vs(t, ds(t)),
                cc: t => zs(t, fs(t)),
                cw: t => zs(t, us(t)),
                cr: t => zs(t, ds(t))
            })[i];
            return r(!!o, `missing impl for ${i}`),
            o(t)
        }(this, n, "repeat") : n;
        for (let r = 0, s = 0; r < e; r++) {
            const e = r * o;
            for (let r = 0; r < t; r++,
            s++)
                a[s] = n(r * i, e)
        }
        return s
    }
    upsize() {
        const {width: t, height: e, data: n} = this
          , r = new ks(2 * t,2 * e,this.format)
          , s = r.data;
        for (let r = 0, a = 0; r < e; r++)
            for (let e = 0, i = r * t * 4; e < t; e++,
            a++,
            i += 2)
                s[i] = n[a];
        return r
    }
}
;
Ns = ks = function(t, e, n, r) {
    var s, a = arguments.length, i = a < 3 ? e : null === r ? r = Object.getOwnPropertyDescriptor(e, n) : r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        i = Reflect.decorate(t, e, n, r);
    else
        for (var o = t.length - 1; o >= 0; o--)
            (s = t[o]) && (i = (a < 3 ? s(i) : a > 3 ? s(e, n, i) : s(e, n)) || i);
    return a > 3 && i && Object.defineProperty(e, n, i),
    i
}([as], Ns);
const Gs = t => {
    const [e,n] = t.size;
    return (r, s) => t.getAtUnsafe(r % e, s % n)
}
  , Is = ({dir: t, size: e, sizeA: n, a: r, b: s}) => "h" === t ? t => t % e < n ? r : s : "v" === t ? (t, a) => a % e < n ? r : s : (t, a) => (t + a) % e < n ? r : s
  , Bs = t => ((null == t || !t[Symbol.iterator]) && W(`value is not iterable: ${t}`),
t);
function _s(t, e) {
    return jt(e) ? Zt(_s(t), e) : e => {
        const n = e[2];
        let r = t;
        return Ft(e, ( (t, e) => r > 0 ? (r--,
        t) : n(t, e)))
    }
}
function js(t, e) {
    return jt(e) ? Jt(js(t), e) : _t(Qt(t), (t => {
        const e = t[2];
        return Ft(t, ( (t, n) => {
            if (n)
                for (let r of Wt(n))
                    if (t = e(t, r),
                    Pt(t))
                        break;
            return Pt(n) ? qt(t) : t
        }
        ))
    }
    ))
}
function *Fs(t, e=1 / 0) {
    for (; e-- > 0; )
        yield t
}
const Ds = ([t,e]) => `t=${t}-${e};s+=t*t;`
  , Cs = t => Ls.add(t, me(t, Ds, "a,b", void 0, "s", "", "let t,s=0;"))
  , Ls = oe();
Ls.default(ye(Ds, "a,b", void 0, "s", "let t,s=0;"));
const Ps = Cs(2)
  , [qs,Ws,Ts,Vs] = (Cs(3),
Cs(4),
we(( ([t,e,n]) => `${t}=${e}+(${n}-${e})*n;`), "o,a,b,n"))
  , Hs = t => Ks.add(t, me(t, ( ([t,e]) => `Math.abs(${t}-${e})`), "a,b", void 0, "", "+", "return ", ";"))
  , Ks = oe();
Ks.default(ye(( ([t,e]) => `sum+=Math.abs(${t}-${e});`), "a,b", void 0, "sum", "let sum=0;"));
const Ys = Hs(2)
  , Js = (Hs(3),
Hs(4),
new class extends s {
    int() {
        return 4294967296 * fxrand() >>> 0
    }
    float(t=1) {
        return fxrand() * t
    }
    norm(t=1) {
        return 2 * (fxrand() - .5) * t
    }
}
)
  , Zs = (t=.5) => Js.float() < t
  , Qs = (t, e) => Js.minmax(t, e)
  , Xs = t => ( (t, e=i, n=0, r=t.length) => t[0 | e.minmax(n, r)])(t, Js)
  , ta = (t, e) => V(t, e, Js)()
  , ea = (t, e) => D(t.copy(), t, .01 * e, Js)
  , na = (t, e) => Ar(ea(t, e))[0]
  , ra = t => jn(t / 255, 0, 0)
  , sa = t => 4278190080 | (t => 65793 * (255 & t))(0 | t)
  , {canvas: aa} = qr(640, 640, document.getElementById("app"))
  , ia = Os(aa)
  , oa = Zs(.9)
  , la = ta([[0], [0, 64], [0, 64, 128], [0, 64, 128, 192]], [8, 4, 2, 1]);
oa && 1 === la.length && la.push(160);
const ha = oa ? ta(["bright", "warm", "hard", "light"], [4, 1, 2, 8]) : "BW"
  , ca = oa ? ur(ha, {
    rnd: Js
}) : ra(la[0])
  , fa = oa ? jn(ca[0], ca[1], M(ca[2] + .5 * Qs(.75, 1.25))) : ra(la[0])
  , ua = 0 | Qs(8, 16)
  , da = 0 | Qs(8, 16)
  , ga = Zs()
  , ba = (t, e) => {
    const n = na(t, e);
    return () => n
}
  , ma = () => ba(ca, ua)
  , pa = () => ba(ra(Xs(la)), 10)
  , ya = () => ba(fa, da)
  , wa = jn(fa[0], fa[1], M(fa[2] + Qs(.1, .2) * (Zs() ? -1 : 1)))
  , Aa = () => {
    const t = ea(fa, da)
      , e = ea(wa, da);
    return n => {
        return r = Ts(t.copy(), t, e, Pr(64, n / 640)),
        Ar(r)[0];
        var r
    }
}
  , $a = () => {
    let t = 127 & Js.int()
      , e = 255;
    return [t,e] = Zs() ? [t, e] : [e, t],
    (n, r) => sa(t + (e - t) * Pr(64, r / 640))
}
  , xa = ta(["S", "M", "L"], [4, 8, 1])
  , va = {
    S: [12, 16, 24, 32],
    M: [16, 24, 32, 40],
    L: [16, 32, 48, 64]
}[xa]
  , Ua = Xs(va);
let Ra = ta([2e3, 4e3, 8e3], [4, 8, 1]);
window.$fxhashFeatures = {
    Hue: "BW" === ha ? "none" : H[vr(xr(ca).h)].toLowerCase(),
    Speed: Ra,
    Theme: ha,
    "Base size": Ua,
    "Color delta": ua,
    "Accent delta": da,
    Gradients: ga,
    Grays: la.length,
    "Pattern range": xa
};
const Ea = t => {
    const e = Zs(.1) ? na(ca, ua) : sa(Xs(la));
    let n = Xs([.25, .5, 1, 2, 3, 4, 6, 8, 12]);
    const r = 0 | Qs(0, t)
      , s = 0 | Qs(2, t);
    return r === s && r === n && n++,
    Ss(t, t, rs, new Uint32Array([...js((a => re(t, _s(a * n, function*(t, e=1 / 0) {
        if (e < 1)
            return;
        let n = [];
        for (let e of t)
            n.push(e),
            yield e;
        if (n.length > 0)
            for (; --e > 0; )
                yield*n
    }(function*(...t) {
        for (let e of t)
            null != e && (yield*Bs(e))
    }(Fs(e, r), Fs(4294967295, s)))))), te(t))]))
}
  , za = (t=!1) => {
    const e = Js.int() % aa.width
      , n = Js.int() % aa.height
      , r = !t && Zs(.2)
      , s = !t && Zs(.1)
      , a = r ? (s ? ya : Zs(.8) ? ma : !ga || Zs(.2) ? pa : $a)() : s ? Xs([ya, ga ? Aa : ya])() : ta([Is({
        a: 4278190080,
        b: 4294967295,
        size: Ua,
        sizeA: Qs(1, Ua),
        dir: Xs("hvd")
    }), Gs(Ea(Xs(va)))], [.25, 1])
      , i = jr(( (t, e) => {
        const n = t >> 16 & 255
          , r = t >> 8 & 255
          , s = 255 & t;
        return e *= e,
        (t, a) => {
            const i = ia.data[t + 640 * a]
              , o = n - (i >> 16 & 255)
              , l = r - (i >> 8 & 255)
              , h = s - (255 & i);
            return o * o + l * l + h * h < e
        }
    }
    )(ia.data[e + 640 * n], 80 * Math.sqrt(3)), e, n, 640, 640)
      , o = Math.max(1e3, Qs(.25, 1) * Ra | 0);
    return [ta([t => t, ka, Sa, Na, Oa], [4, 2, 1, 1, 2])(i, [e, n]), a, o]
}
  , Ma = () => Zs() ? Rr : Er;
function *ka(t) {
    yield*o([...t], void 0, Js)
}
function *Sa(t, e) {
    yield*f([...t], (t => Ps(e, t)), Ma())
}
function *Oa(t, e) {
    yield*f([...t], (t => Ys(e, t)), Ma())
}
function *Na(t) {
    yield*[...t].sort(function(t, e, n=l, r=l) {
        const s = Ur(t)
          , a = Ur(e);
        return (t, e) => {
            let i = n(s(t), s(e));
            return 0 === i ? r(a(t), a(e)) : i
        }
    }(0, 1, Ma(), Rr))
}
let Ga = za(!0);
const Ia = (t=0) => {
    let[e,n,r] = Ga;
    for (let s = t || r; s-- > 0; ) {
        const t = e.next();
        if (t.done) {
            Ga = za(),
            [e,n,r] = Ga;
            continue
        }
        const {0: s, 1: a} = t.value;
        ia.data[s + 640 * a] = n(s, a)
    }
    ia.blitCanvas(aa)
}
;
Ia(1e6),
setInterval(Ia, 16),
console.log(fxhash, window.$fxhashFeatures);
//# sourceMappingURL=index.4174ce2d.js.map
